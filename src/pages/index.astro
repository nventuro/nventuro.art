---
import BaseLayout from '../layouts/BaseLayout.astro';
import MiniatureGrid from '../components/MiniatureGrid.astro';
import FilterBar from '../components/FilterBar.astro';
import { getCollection } from 'astro:content';

const miniatures = (await getCollection('miniatures')).sort((a, b) => {
  const dateDiff = b.data.date.getTime() - a.data.date.getTime();
  if (dateDiff !== 0) return dateDiff;
  return (a.data.order ?? Infinity) - (b.data.order ?? Infinity);
});

// Load logo images for filter chips (same pattern as MiniatureGrid)
const logoFiles = import.meta.glob<{ default: ImageMetadata }>('/src/assets/logos/**/*.png', { eager: true });

function toKebabCase(name: string): string {
  return name.toLowerCase().replace(/\s+/g, '-');
}

function getLogoSrc(type: string, name: string): string {
  const key = `/src/assets/logos/${type}/${toKebabCase(name)}.png`;
  const match = logoFiles[key];
  if (!match) return '';
  return match.default.src;
}

function getLogoLightSrc(type: string, name: string): string | null {
  const key = `/src/assets/logos/${type}/${toKebabCase(name)}-light.png`;
  const match = logoFiles[key];
  if (!match) return null;
  return match.default.src;
}

// Validate logos exist for all manufacturers, games, and factions
const logoErrors: string[] = [];
const manufacturers = new Set(miniatures.map(m => m.data.manufacturer));
const games = new Set(miniatures.map(m => m.data.game).filter(Boolean));
const factions = new Set(miniatures.map(m => m.data.faction).filter(Boolean));

for (const name of manufacturers) {
  if (!getLogoSrc('manufacturers', name)) {
    logoErrors.push(`Missing manufacturer logo: src/assets/logos/manufacturers/${toKebabCase(name)}.png`);
  }
}
for (const name of games) {
  if (!getLogoSrc('games', name!)) {
    logoErrors.push(`Missing game logo: src/assets/logos/games/${toKebabCase(name!)}.png`);
  }
}
for (const name of factions) {
  if (!getLogoSrc('factions', name!)) {
    logoErrors.push(`Missing faction logo: src/assets/logos/factions/${toKebabCase(name!)}.png`);
  }
}
if (logoErrors.length) {
  throw new Error('Missing logos:\n  ' + logoErrors.join('\n  '));
}

// Validate no orphan photos in src/assets/photos/
const photoFiles = import.meta.glob<{ default: ImageMetadata }>('/src/assets/photos/**/*.png', { eager: true });
const referencedPhotos = new Set<string>();
for (const miniature of miniatures) {
  for (const photo of miniature.data.photos) {
    referencedPhotos.add(photo.src);
  }
}
const orphanPhotos = Object.keys(photoFiles).filter(key => {
  const src = photoFiles[key].default.src;
  return !referencedPhotos.has(src);
});
if (orphanPhotos.length) {
  throw new Error('Orphan photos (not referenced by any miniature):\n  ' + orphanPhotos.join('\n  '));
}

// Build filter metadata: count by manufacturer and by faction (with parent manufacturer)
const manufacturerCounts = new Map<string, number>();
const factionData = new Map<string, { count: number; manufacturer: string }>();

for (const miniature of miniatures) {
  const m = miniature.data.manufacturer;
  manufacturerCounts.set(m, (manufacturerCounts.get(m) || 0) + 1);

  if (miniature.data.faction) {
    const f = miniature.data.faction;
    const existing = factionData.get(f);
    if (existing) {
      existing.count++;
    } else {
      factionData.set(f, { count: 1, manufacturer: m });
    }
  }
}

// Build ordered filterGroups: manufacturer chip + its faction chips, grouped
const filterGroups = Array.from(manufacturerCounts.entries())
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([manufacturer, count]) => {
    const chips: { type: 'manufacturer' | 'faction'; value: string; manufacturer: string; count: number; logoSrc: string; logoLightSrc: string | null }[] = [];

    chips.push({
      type: 'manufacturer',
      value: manufacturer,
      manufacturer,
      count,
      logoSrc: getLogoSrc('manufacturers', manufacturer),
      logoLightSrc: getLogoLightSrc('manufacturers', manufacturer),
    });

    // Add faction chips that belong to this manufacturer
    Array.from(factionData.entries())
      .filter(([, data]) => data.manufacturer === manufacturer)
      .sort(([a], [b]) => a.localeCompare(b))
      .forEach(([faction, data]) => {
        chips.push({
          type: 'faction',
          value: faction,
          manufacturer,
          count: data.count,
          logoSrc: getLogoSrc('factions', faction),
          logoLightSrc: getLogoLightSrc('factions', faction),
        });
      });

    return { manufacturer, chips };
  });
---

<BaseLayout title="nivvok.art â€” Painted Miniatures Gallery">
  <h1>Gallery</h1>
  <FilterBar filterGroups={filterGroups} />
  <MiniatureGrid miniatures={miniatures} />
</BaseLayout>

<style>
  h1 {
    margin-bottom: 1.5rem;
    font-size: 1.75rem;
  }
</style>
