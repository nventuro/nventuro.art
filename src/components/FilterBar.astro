---
interface FilterChip {
  type: 'manufacturer' | 'faction';
  value: string;
  manufacturer: string;
  count: number;
  logoSrc: string;
}

interface FilterGroup {
  manufacturer: string;
  chips: FilterChip[];
}

interface Props {
  filterGroups: FilterGroup[];
}

const { filterGroups } = Astro.props;
---

<div class="filter-bar">
  <div class="search-wrapper">
    <svg class="search-icon" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="6.5" cy="6.5" r="5" />
      <path d="M10 10l4.5 4.5" />
    </svg>
    <input type="text" id="search-input" class="search-input" placeholder="Search miniatures..." />
    <button class="search-clear" type="button" aria-label="Clear search">&times;</button>
  </div>
  <div class="filter-bar-header">
    <button class="filter-toggle" aria-expanded="false" aria-controls="filter-chips">
      <svg class="funnel-icon" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M1.5 1.5h13l-5 6v5l-3 2v-7z" />
      </svg>
      Filter
    </button>
  </div>
  <div id="filter-chips" class="filter-chips">
    {filterGroups.map((group) => (
      <div class="filter-group">
        {group.chips.map((chip) => (
          <button
            class="filter-chip"
            data-filter-type={chip.type}
            data-filter-value={chip.value}
          >
            <img class="chip-logo" src={chip.logoSrc} alt="" width="18" height="18" />
            <span class="chip-label">{chip.value}</span>
            <span class="chip-count">{chip.count}</span>
          </button>
        ))}
      </div>
    ))}
    <a class="filter-clear" href="#" role="button">Clear</a>
  </div>
</div>

<script>
  const activeFilters = new Set<string>();
  let searchQuery = '';
  let pushStateTimer: number;

  const searchInput = document.getElementById('search-input') as HTMLInputElement;
  const searchClear = document.querySelector('.search-clear') as HTMLElement;

  function makeKey(type: string, value: string): string {
    return `${type}:${value}`;
  }

  function applyFilters() {
    const gallery = document.getElementById('gallery');
    if (!gallery) return;

    const items = gallery.querySelectorAll('.miniature-item');
    const chips = document.querySelectorAll('.filter-chip');
    const filterClear = document.querySelector('.filter-clear') as HTMLElement;
    const noResults = gallery.querySelector('.no-results') as HTMLElement;

    const selectedManufacturers = new Set<string>();
    const selectedFactions = new Set<string>();

    activeFilters.forEach((key) => {
      const [type, ...rest] = key.split(':');
      const value = rest.join(':');
      if (type === 'manufacturer') selectedManufacturers.add(value);
      if (type === 'faction') selectedFactions.add(value);
    });

    const hasChipFilters = activeFilters.size > 0;
    const searchWords = searchQuery.trim().toLowerCase().split(/\s+/).filter(Boolean);
    const hasSearch = searchWords.length > 0;
    const hasAnyFilter = hasChipFilters || hasSearch;
    let visibleCount = 0;

    items.forEach((el) => {
      const item = el as HTMLElement;
      const manufacturer = item.dataset.manufacturer || '';
      const faction = item.dataset.faction || '';
      const title = item.dataset.title || '';
      const game = item.dataset.game || '';

      const passesChipFilter = !hasChipFilters ||
        selectedManufacturers.has(manufacturer) ||
        (faction && selectedFactions.has(faction));

      let passesSearch = true;
      if (hasSearch) {
        const haystack = `${title} ${manufacturer} ${game} ${faction}`.toLowerCase();
        passesSearch = searchWords.every((word) => haystack.includes(word));
      }

      const shouldShow = passesChipFilter && passesSearch;
      const isCurrentlyHidden = item.classList.contains('filtered-out') || item.classList.contains('filtering-out');

      if (shouldShow) {
        visibleCount++;
        if (isCurrentlyHidden) {
          item.classList.remove('filtered-out', 'filtering-out');
          item.classList.add('filtering-in');
          setTimeout(() => item.classList.remove('filtering-in'), 300);
        }
      } else {
        if (!isCurrentlyHidden) {
          item.classList.add('filtering-out');
          setTimeout(() => {
            if (item.classList.contains('filtering-out')) {
              item.classList.remove('filtering-out');
              item.classList.add('filtered-out');
            }
          }, 300);
        }
      }
    });

    // Update chip active states
    chips.forEach((chip) => {
      const btn = chip as HTMLElement;
      const key = makeKey(btn.dataset.filterType!, btn.dataset.filterValue!);
      btn.classList.toggle('active', activeFilters.has(key));
    });

    // Show/hide filter clear button
    if (filterClear) {
      filterClear.classList.toggle('visible', hasChipFilters);
    }

    // Show/hide search clear button and active state
    if (searchClear) {
      searchClear.classList.toggle('visible', hasSearch);
    }
    const searchWrapper = document.querySelector('.search-wrapper') as HTMLElement;
    if (searchWrapper) {
      searchWrapper.classList.toggle('active', hasSearch);
    }

    // Empty state
    if (noResults) {
      noResults.classList.toggle('visible', hasAnyFilter && visibleCount === 0);
    }

    // Update URL
    const params = new URLSearchParams();
    selectedManufacturers.forEach((m) => params.append('manufacturer', m));
    selectedFactions.forEach((f) => params.append('faction', f));
    if (searchQuery.trim()) params.set('q', searchQuery.trim());
    const qs = params.toString();
    const newUrl = qs ? `${window.location.pathname}?${qs}` : window.location.pathname;
    history.replaceState(null, '', newUrl + window.location.hash);
  }

  // Chip click handler via event delegation
  const chipsContainer = document.getElementById('filter-chips');
  if (chipsContainer) {
    chipsContainer.addEventListener('click', (e) => {
      const chip = (e.target as HTMLElement).closest('.filter-chip') as HTMLElement;
      if (!chip) return;

      const key = makeKey(chip.dataset.filterType!, chip.dataset.filterValue!);
      if (activeFilters.has(key)) {
        activeFilters.delete(key);
      } else {
        activeFilters.add(key);
      }
      applyFilters();
    });
  }

  // Filter clear button (clears chip filters only)
  const filterClear = document.querySelector('.filter-clear');
  if (filterClear) {
    filterClear.addEventListener('click', (e) => {
      e.preventDefault();
      activeFilters.clear();
      applyFilters();
    });
  }

  // Search input handler
  if (searchInput) {
    searchInput.addEventListener('input', () => {
      searchQuery = searchInput.value;
      applyFilters();

      // Debounced pushState so browser back button works
      clearTimeout(pushStateTimer);
      pushStateTimer = window.setTimeout(() => {
        history.pushState(null, '', window.location.href);
      }, 800);
    });
  }

  // Search clear button (clears search only)
  if (searchClear) {
    searchClear.addEventListener('click', () => {
      searchQuery = '';
      if (searchInput) {
        searchInput.value = '';
        searchInput.focus();
      }
      applyFilters();
    });
  }

  // Mobile toggle
  const toggleBtn = document.querySelector('.filter-toggle');
  if (toggleBtn && chipsContainer) {
    toggleBtn.addEventListener('click', () => {
      const expanded = chipsContainer.classList.toggle('expanded');
      toggleBtn.setAttribute('aria-expanded', String(expanded));
    });
  }

  // Init from URL
  const params = new URLSearchParams(window.location.search);
  params.getAll('manufacturer').forEach((m) => activeFilters.add(makeKey('manufacturer', m)));
  params.getAll('faction').forEach((f) => activeFilters.add(makeKey('faction', f)));

  const initQuery = params.get('q') || '';
  if (initQuery) {
    searchQuery = initQuery;
    if (searchInput) searchInput.value = initQuery;
  }

  if (activeFilters.size > 0 || searchQuery) {
    applyFilters();
    // Auto-expand mobile chip panel only for chip filters
    if (activeFilters.size > 0 && chipsContainer && toggleBtn) {
      chipsContainer.classList.add('expanded');
      toggleBtn.setAttribute('aria-expanded', 'true');
    }
  }

  // Skip animations on initial load: promote filtering-out to filtered-out immediately,
  // and remove filtering-in, so items appear in their final positions with no movement.
  const gallery = document.getElementById('gallery');
  if (gallery) {
    gallery.querySelectorAll('.filtering-out').forEach((el) => {
      el.classList.remove('filtering-out');
      el.classList.add('filtered-out');
    });
    gallery.querySelectorAll('.filtering-in').forEach((el) => {
      el.classList.remove('filtering-in');
    });
    gallery.classList.remove('pre-filter');
  }

  // Back/forward navigation
  window.addEventListener('popstate', () => {
    const p = new URLSearchParams(window.location.search);

    activeFilters.clear();
    p.getAll('manufacturer').forEach((m) => activeFilters.add(makeKey('manufacturer', m)));
    p.getAll('faction').forEach((f) => activeFilters.add(makeKey('faction', f)));

    searchQuery = p.get('q') || '';
    if (searchInput) searchInput.value = searchQuery;

    applyFilters();
  });
</script>

<style>
  .filter-bar {
    margin-bottom: 1.5rem;
  }

  .search-wrapper {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    border: 1px solid var(--color-border);
    border-radius: 999px;
    padding: 0.3rem 0.65rem;
    margin-bottom: 0.75rem;
    transition: border-color 0.3s;
  }

  .search-wrapper:focus-within {
    border-color: var(--color-text-muted);
  }

  .search-wrapper.active {
    background: color-mix(in srgb, var(--color-text) 12%, transparent);
    border-color: var(--color-text);
  }

  .search-icon {
    width: 14px;
    height: 14px;
    flex-shrink: 0;
    opacity: 0.5;
  }

  .search-input {
    flex: 1;
    background: transparent;
    border: none;
    outline: none;
    color: var(--color-text);
    font: inherit;
    font-size: 0.875rem;
    min-width: 0;
  }

  .search-input::placeholder {
    color: var(--color-text-muted);
  }

  .search-clear {
    display: none;
    align-items: center;
    justify-content: center;
    background: none;
    border: none;
    color: var(--color-text-muted);
    cursor: pointer;
    font-size: 1.1rem;
    line-height: 1;
    padding: 0 0.15rem;
    transition: color 0.2s;
  }

  .search-clear:hover {
    color: var(--color-text);
  }

  .search-clear.visible {
    display: inline-flex;
  }

  .filter-bar-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .filter-toggle {
    display: none;
    align-items: center;
    gap: 0.4rem;
    background: none;
    border: 1px solid var(--color-border);
    color: var(--color-text);
    padding: 0.4rem 0.75rem;
    border-radius: 999px;
    cursor: pointer;
    font-size: 0.875rem;
    transition: border-color 0.3s, color 0.3s;
  }

  .funnel-icon {
    width: 14px;
    height: 14px;
    flex-shrink: 0;
  }

  .filter-clear {
    display: none;
    align-items: center;
    color: var(--color-text-muted);
    font-size: 0.8125rem;
    text-decoration: none;
    transition: color 0.2s;
  }

  .filter-clear:hover {
    color: var(--color-text);
  }

  .filter-clear.visible {
    display: inline-flex;
  }

  .filter-chips {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .filter-group {
    display: contents;
  }

  .filter-chip {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.3rem 0.65rem;
    border: 1px solid var(--color-border);
    border-radius: 999px;
    background: transparent;
    color: var(--color-text);
    cursor: pointer;
    font-size: 0.8125rem;
    transition: background 0.2s, color 0.2s, border-color 0.3s;
    white-space: nowrap;
  }

  .filter-chip:hover {
    border-color: var(--color-text-muted);
  }

  .filter-chip.active {
    background: color-mix(in srgb, var(--color-text) 12%, transparent);
    border-color: var(--color-text);
  }

  .chip-logo {
    width: 18px;
    height: 18px;
    object-fit: contain;
    border-radius: 2px;
  }

  .chip-count {
    opacity: 0.5;
    font-size: 0.75rem;
  }

  @media (max-width: 768px) {
    .filter-bar-header {
      margin-bottom: 0.75rem;
    }

    .filter-toggle {
      display: inline-flex;
    }

    .filter-chips {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .filter-chips.expanded {
      max-height: 500px;
    }

    .filter-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      width: 100%;
    }
  }
</style>
